<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="ByteBlog"><meta property="og:type" content="article"><meta name=robots content="index,follow,noarchive"><meta property="og:image" content="//img/home-bg-jeep.jpg"><meta property="twitter:image" content="//img/home-bg-jeep.jpg"><meta name=title content="The GPU Feature Set For the Next Generation of Games"><meta property="og:title" content="The GPU Feature Set For the Next Generation of Games"><meta property="twitter:title" content="The GPU Feature Set For the Next Generation of Games"><meta name=description content="While the 2020 Game Developers Conference has been postponed, that thankfully doesnt mean everything gaming-related for this spring has been postponed as well. As the saying goes, the show must go on, and this week weve seen Microsoft, Sony, and others go ahead and make some big announcements about their gaming consoles and other projects."><meta property="og:description" content="While the 2020 Game Developers Conference has been postponed, that thankfully doesnt mean everything gaming-related for this spring has been postponed as well. As the saying goes, the show must go on, and this week weve seen Microsoft, Sony, and others go ahead and make some big announcements about their gaming consoles and other projects."><meta property="twitter:description" content="While the 2020 Game Developers Conference has been postponed, that thankfully doesnt mean everything gaming-related for this spring has been postponed as well. As the saying goes, the show must go on, and this week weve seen Microsoft, Sony, and others go ahead and make some big announcements about their gaming consoles and other projects."><meta property="twitter:card" content="summary"><meta name=keyword content><link rel="shortcut icon" href=./img/favicon.ico><title>The GPU Feature Set For the Next Generation of Games |</title><link rel=canonical href=./microsoft-intros-directx-12-ultimate-next-gen-feature-set.html><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cleanwhite/css/bootstrap.min.css><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cleanwhite/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cleanwhite/css/zanshang.css><link href=https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css rel=stylesheet type=text/css><script src=https://assets.cdnweb.info/hugo/cleanwhite/js/jquery.min.js></script>
<script src=https://assets.cdnweb.info/hugo/cleanwhite/js/bootstrap.min.js></script>
<script src=https://assets.cdnweb.info/hugo/cleanwhite/js/hux-blog.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=./>ByteBlog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=./categories/blog>blog</a></li><li><a href=./sitemap.xml>Sitemap</a></li><li><a href=./index.xml>RSS</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home-bg-jeep.jpg)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags></div><h1>The GPU Feature Set For the Next Generation of Games</h1><h2 class=subheading></h2><span class=meta>Posted by
Aldo Pusey
on
Monday, October 7, 2024</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>While the 2020 Game Developers Conference has been postponed, that thankfully doesn’t mean everything gaming-related for this spring has been postponed as well. As the saying goes, the show must go on, and this week we’ve seen Microsoft, Sony, and others go ahead and make some big announcements about their gaming consoles and other projects. Not to be left out of the fray, there is PC-related news coming out of the show as well.</p><p>Leading the PC pack this week is Microsoft (again), with the announcement of DirectX 12 Ultimate. Designed as a new, standardized DirectX 12 feature set that encapsulates the latest in GPU technology, DirectX 12 Ultimate is intended to serve as a common baseline for both PC game development and Xbox Series X development. This includes not only wrapping up features like ray tracing and variable rate shading into a single package, but then branding that package so that developers and the public at large can more easily infer whether games are using these cutting-edge features, and whether their hardware supports it. And, of course, this allows Microsoft to maximize the synergy between PC gaming and their forthcoming console, giving developers a single feature set to base their projects around while promoting the fact that the latest Xbox will support the very latest GPU features.</p><p>To be sure, what’s being announced today isn’t a new API – even the features being discussed today technically aren’t new – but rather it’s a newly defined feature set that wraps up several features that Microsoft and its partners have been working on over the past few years. This includes DirectX Raytracing, Variable Rate Shading, Mesh Shaders and Sampler Feedback. Most of these features have been available in some form for a time now as separate features within DirectX 12, but the creation of DirectX 12 Ultimate marks their official promotion from in-development or early adaptor status to being ready for the masses at large.</p><p>For Microsoft, the importance of DirectX 12 Ultimate is twofold. First, DirectX has accumulated a lot of new features since its last feature set, <a href=#>feature level 12_1</a>, was defined over half a decade ago. So DirectX has been overdue to package up features introduced by things like NVIDIA’s Turing GPU architecture as well as AMD’s forthcoming RDNA2 architecture. The end result of that process is the new feature level 12_2, or as it’s being branded, DirectX 12 Ultimate.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/15637/Xbox-Series-X-Crop_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Second, this is the first console launch for Microsoft where DirectX 12 has been ready and available at launch. While Microsoft has always attempted to take advantage of the synergy between PC and console, the fact that DirectX 12 was finalized after the Xbox One family launch meant that the past generation has been somewhat misaligned. So similar to the current-generation consoles being the true kick-off point for DirectX 11 becoming the baseline for video game development, Microsoft is aiming to do the same for the next-gen consoles and DirectX 12; and they’re trying to do it in a more organized fashion than ever before.</p><p>Of course, it doesn’t hurt that this also lets Microsoft talk up the Xbox Series X as being on the same level as (current) PC GPUs. The long lifecycle of consoles means that by mid-generation they’re outpaced by PC GPUs in teams of features, and while the two products are not perfect substitutes for each other in an economic sense, it becomes one less thing that game consoles have going for themselves, and one more advantage for the PC. So by giving the new feature level a public brand, Microsoft can clearly communicate that they are on the cutting edge of GPU technology period; there is no PC GPU that can surpass them in terms of features.</p><p>And clarity is an important goal here not just for marketing reasons, but customer relations in general. The features being bundled under the DirectX 12 Ultimate banner are significant, and mesh shaders in particular stand to allow developers to completely upend the traditional rendering pipeline. So when developers start using these features as a true baseline in future games – and to be sure, that’s likely to be some time off – then the requirements need to be clearly communicated to PC gamers. It won’t be enough for a video card to just support DirectX 12, it will need to support (at a minimum) this new feature set to meet that baseline. But even in the present, where games will continue to work on multiple generations of GPUs for some time to come, the DirectX 12 Ultimate branding is useful for clearly explaining what kind of hardware it will take to access the new features that forthcoming games will be using.</p><h2>The Features of DirectX 12 Ultimate (aka DX12 feature level 12_2)</h2><p>Diving into the new feature level itself, as I previously mentioned, the new feature set is designed to encapsulate new GPU features introduced in the last few years. This means tying together existing features like ray tracing and mesh shaders into a new feature level, so that they can be more readily targeted by developers.</p><p>All told – and much to the glee of NVIDIA – DirectX 12 Ultimate’s feature set ends up looking a whole heck of a lot like their Turing architecture’s graphics feature set. Ray tracing, mesh shading, and variable rate shading were all introduced for the first time on Turing, and this represents the current cutting edge for GPU graphics functionality. Consequently, it’s no mistake that this new feature level, which Microsoft is internally calling 12_2, follows the Turing blueprint so closely. Feature levels are a collaboration between Microsoft and all of the GPU vendors, with feature levels representing a common set of features that everyone can agree to support.</p><p>Ultimately, this collaboration and timing means that there is already current-generation hardware out there that meets the requirements for 12_2 with NVIDIA’s GeForce 16 and 20 series (Turing) products. And while AMD and Intel are a bit farther behind the curve, they’ll get there as well. In fact in a lot of ways AMD’s forthcoming RDNA2 architecture, which has been at the heart of this week’s console announcements, will serve as the counterbalance to Turing as far as 12_2 goes. This is a feature set that crosses PCs and consoles, and while NVIDIA may dominate the PC space, what AMD is doing with RDNA2 is defining an entire generation of consoles for years to come.</p><table align=center border=1 cellpadding=3 cellspacing=0 width=650><tbody readability=8><tr class=tgrey readability=2><td align=center colspan=6>DirectX 12 Feature Levels</td></tr><tr class=tlblue><td align=center class=contentwhite width=168>&nbsp;</td><td align=center class=contentwhite width=110>12_2<br>(DX12 Ult.)</td><td align=center class=contentwhite width=110>12_1</td><td align=center class=contentwhite width=110>12_0</td></tr><tr readability=8><td align=left class=tlgrey><strong>GPU Architectures<br>(Introduced as of)</strong></td><td align=center>NVIDIA: Turing<br>AMD: RDNA2<br>Intel: Xe?</td><td align=center>NVIDIA: Maxwell 2<br>AMD: Vega<br>Intel: Gen9</td><td align=center>NVIDIA: Maxwell 2<br>AMD: Hawaii<br>Intel: Gen9</td></tr><tr><td align=left class=tlgrey><strong>Ray Tracing<br>(DXR 1.1)</strong></td><td align=center><strong>Yes</strong></td><td align=center>No</td><td align=center>No</td></tr><tr readability=2><td align=left class=tlgrey><strong>Variable Rate Shading<br>(Tier 2)</strong></td><td align=center><strong>Yes</strong></td><td align=center>No</td><td align=center>No</td></tr><tr><td align=left class=tlgrey><strong>Mesh Shaders</strong></td><td align=center><strong>Yes</strong></td><td align=center>No</td><td align=center>No</td></tr><tr><td align=left class=tlgrey><strong>Sampler Feedback</strong></td><td align=center><strong>Yes</strong></td><td align=center>No</td><td align=center>No</td></tr><tr readability=2><td align=left class=tlgrey><strong>Conservative Rasterization</strong></td><td align=center>Yes</td><td align=center>Yes</td><td align=center>No</td></tr><tr><td align=left class=tlgrey><strong>Raster Order Views</strong></td><td align=center>Yes</td><td align=center>Yes</td><td align=center>No</td></tr><tr><td align=left class=tlgrey><strong>Tiled Resources<br>(Tier 2)</strong></td><td align=center>Yes</td><td align=center>Yes</td><td align=center>Yes</td></tr><tr readability=2><td align=left class=tlgrey><strong>Bindless Resources<br>(Tier 2)</strong></td><td align=center>Yes</td><td align=center>Yes</td><td align=center>Yes</td></tr><tr><td align=left class=tlgrey><strong>Typed UAV Load</strong></td><td align=center>Yes</td><td align=center>Yes</td><td align=center>Yes</td></tr></tbody></table><p>Overall, there are four big features that Microsoft and partners are focusing on for 12_2, at least publicly. These are ray tracing, variable rate shading, mesh shaders, and sampler feedback. Some of these features, particularly ray tracing, have been available in DirectX 12 for a while, and all of them have been <a href=#>previously announced by Microsoft</a> as they’ve worked with developers to refine them. None the less, even ray tracing is getting some important feature updates to coincide with 12_2, so as a whole the new feature level brings a lot of new toys to the table for game developers to play with.</p><p>As for gamers, the Windows introduction of 12_2 is set to occur in the next couple of months, when Microsoft ships their next big Windows 10 feature update, Windows 10 version 2004 (also known as 20H1). And while games using the new feature level will be slow to trickle out (like any new feature level launch), it does mean that gamers will need to stick to the latest Windows to use it. Holding back a version or two (as some of us are want to do) means no DX12U for you.</p><h3>Raytracing with DXR 1.1</h3><p>Kicking off the feature level 12_2 family is raytracing support. The raytracing component of DX12 <a href=#>was first introduced by Microsoft back in 2018</a>, and it has been available for developer use for a while now. I’m not going to recap raytracing in detail here – <a href=#>we’ve written about it a few times now</a> – but at a high level it’s going to play an important part in future games. Essentially simulating the way that real light is projected and interacts with the world, raytracing is designed to take over in areas where the current rasterization rendering paradigm has been stretched to its limits. Developers have been able to do a ton of amazing things for lighting with incredibly clever hacks on rasterization, but there are some areas where the quality or performance of actually casting light (rays) simply cannot be beat. And this is where hardware raytracing fits in.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/12547/1024px-ray_trace_diagram.svg_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a><br>Ray Tracing Diagram (<a href=#>Henrik</a> / CC BY-SA 4.0)</p><p>Though it was officially a complete and shipping standard, the original 1.0 standard was none the less a bit experimental in nature. By its very nature it was designed around the hardware at the time (Turing) and no one was entirely sure what developers would do with raytracing. So for raytracing’s inclusion into a full DirectX feature level, the raytracing API itself is seeming some enhancements.</p><p>The new DXR 1.1 standard extends 1.0 in several ways, to incorporate new features that developers have asked for in the last couple of years. And because it’s only comprised of new software functionality, that means that it works on existing Turing hardware as well. So in practice, DXR 1.1 is going to supplant DXR 1.0 going forward, and no one outside of developers should be any wiser.</p><p>The big additions for DXR 1.1 are primarily focused on making it easier or more efficient for developers to use raytracing in their games. Heading up this list is the ability to spawn raytracing tasks on the GPU itself, without requiring the host CPU to do it. This is something the GPU can already do in other situations – particularly having compute kernels spawn other compute kernels via dynamic parallelism – and now the same concept is being extended to raytracing. Microsoft sees this feature as being helpful for scenarios where the GPU would want to prepare raytracing work and them immediately spawn it anyhow, such as shaders using raytracing as a means of culling. Which, to be sure, is doable even under DXR 1.0; but the fact that the CPU would have to invoke it makes it less efficient.</p><p>The other major addition here is what Microsoft is calling <strong>inline raytracing</strong>. Perhaps best conceptualized as a stripped-down version of raytracing for simple tasks, inline raytracing exposes raytracing to more stages of the GPU rendering process, thereby allowing developers to take more direct control over raytracing and potentially use it in more places. Of particular note here, inline raytracing can be invoked in shader stages that can’t invoke regular raytracing, such as compute shaders, giving developers more flexibility. Overall, inline raytracing comes with less overhead for simple tasks, making them a better fit for that scenario, while traditional raytracing (and its better scheduling mechanisms) are going to be superior for complex tasks.</p><h3>Variable Rate Shading</h3><p>The second feature getting bundled into 12_2 is variable rate shading. Another Turing architecture launch feature, Microsoft began incorporating VRS into DirectX last year.</p><p>At a high level, variable rate shading allows for the rate of shading operations to be varied within a frame. Rather than running pixel and other shaders at a 1:1 rate with individual pixels, the shading rate can be dialed up or dialed down to focus on improved quality or reducing the rendering workload in certain areas. Developer use is primarily going to be focused on the latter of the two, with developers using it to cut back on the amount of shading done in areas of a screen where that level of detail is unnecessary – or at least unlikely to be noticed.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/15637/Tier2-Default-side-by-side_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Variable rate shading already has two tiers, and feature level 12_2 will be incorporating the second, more powerful tier of that feature. Tier 2 allows for the shading rate to be varied within a draw call, allowing for a relatively fine-grained approach to where the shading rate is adjusted. This can be done on per-primitive basis, or by defining general areas in a frame where the rate should be adjusted (screenspace).</p><p>Variable rate shading has already been optionally used in a few games to date, particularly Wolfenstein II, but its current use isn’t as widespread as raytracing.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/15637/NV_9_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>And while the primary use for variable rate shading is going to be on improving performance by selectively reducing the shading resolution – especially for the 4K resolution gaming Microsoft wants to do on the Xbox Series X – the feature is also set to play a part in VR headsets. Variable rate shading is the core rendering technology behind making foveated rendering possible, which itself promises significant efficiency gains for VR headsets. By only rendering the center of the user’s vision at full resolution (if not higher, for improved clarity), the amount of work required to render a VR frame is significantly reduced. This can help bring down the costs of VR by requiring less powerful hardware, or it can be used to free up performance for even better-looking games.</p><h3>Mesh Shaders: The Next Generation Geometry Pipeline</h3><p>The third feature on the 12_2 list is mesh shaders. And truth be told, nothing I’m going to write here is going to quite do them justice.</p><p>At a very high level, mesh shading is the basis for next-generation geometry pipelines. The current geometry pipeline paradigm has essentially had new stages bolted on to it at multiple points over the last twenty years, with features like geometry shaders and tessellation tacked on to extend the pipeline. But the core concept of this pipeline is still based on traditional, pre-pixel shader rasterization methods, and this brings with it unnecessary complexity and inefficiency.</p><p>Thus, hardware and software developers alike want to throw out the current geometry pipeline in favor of something new, and that new thing is mesh shaders.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/15637/MeshShaderPipeline_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Mesh shaders are perhaps best thought of as compute shaders for geometry. The significance of which being that modern compute shaders are incredibly powerful by virtue of not only their parallelism, but their flexibility in terms of how data is processed and routed. Basically, instead of making developers follow a rigid pipeline to setup their geometry, mesh shaders let developers take near complete control to do it as they see fit.</p><p>Mesh shaders can also optionally be used with amplification shaders. I won’t go into those too much, but the basic principle there is to help setup data for the mesh shaders. Microsoft notes that they’re particularly useful for culling, though that isn’t their only use.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/15637/NV_10_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Ultimately, the goal of mesh shaders is to significantly improve the efficiency of the geometry pipeline, and thereby give developers the performance headroom to use ever more detailed geometry. This is accomplishing by removing overhead at several levels, as well as making it practical to do very geometry culling, stopping geometry before it would hit the vertex shader. Mesh shaders will also allow for index buffer compression, with an eye towards mitigating the memory bandwidth cost of using very complex geometry.</p><p>The catch to all of this, as is often the case, is how quickly developers can adopt it. Mesh shaders throw out a tried and true geometry pipeline for something new entirely, which means developers will need to become accustomed to it. It’s a big change from a game development standpoint, and consequently it’s very much a “baseline” feature. So mesh shading is something developers can really only do when they rebuild their engines for the next generation of consoles, where they no longer need to support pre-12_2 hardware.</p><h3>Sampler Feedback</h3><p>The final marquee feature for Direct X 12 Ultimate/feature level 12_2 is sampler feedback. This is a very new feature that has only recently been exposed, and has received very little publicity so far; though like everything else here, the hardware capabilities first showed up in Turing.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/15637/NV_11_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Previously demoed by NVIDIA as texture-space shading, sampler feedback is a broader feature with a few different uses. At a very high level, the idea behind sampler feedback is to allow game engines to track how the texture samplers are being (or will be) used – thus, the samplers give feedback to the engine – allowing the engine to make more intelligent decisions about how the samplers are used and what resources are kept in VRAM.</p><p>The principle use case for this, Microsoft envisions, will be in improving texture streaming. By using sampler feedback, game engines can determine what texture tiles are actually going to be needed, and thus only loading up the necessary tiles. This keeps overall VRAM pressure down, ultimately allowing developers to use higher quality textures overall by losing less VRAM to unneeded tiles. Fittingly for the Xbox Series X, this is especially handy when your games are stored on a high speed SSD, as it means the necessary tiles can be pulled in from storage incredibly quickly (almost in a just-in-time fashion), instead of having to stage them in RAM or take measures to mitigate the long access time of a HDD.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/15637/TSS_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Meanwhile texture-space shading is the other major use for this feature. Another efficiency technique, texture-space shading allows for the shading of an object to take place without actually rasterizing it. Microsoft’s example here involves lighting – where an object has its lighting calculated once instead of repeatedly as a rasterized object would require. Ultimately, the central idea behind this feature is to be able to cache and reuse shading results, freeing up GPU resources for other, more important tasks.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZH52gpJwZqahk6e8tLvFrWSipqSnvLR5w6KpnpukrXpyfoyuo62hnZbBpnnNnq%2BtZZeau26yxJqrrqqVYsCmwA%3D%3D</p><hr><ul class=pager><li class=previous><a href=./aladar-24856.html data-toggle=tooltip data-placement=top title="Aladar | Page 4 | Bulbagarden">&larr;
Previous Post</a></li><li class=next><a href=./the-10-strongest-fullmetal-alchemist-brotherhood-characters-ranked.html data-toggle=tooltip data-placement=top title="The 10 Strongest Fullmetal Alchemist: Brotherhood Characters, Ranked">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=./tags/>FEATURED TAGS</a></h5><div class=tags></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"></ul><p class="copyright text-muted">Copyright &copy; ByteBlog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(i,t){var n=document,s="script",e=n.createElement(s),o=n.getElementsByTagName(s)[0];e.src=i,t&&e.addEventListener("load",function(e){t(null,e)},!1),o.parentNode.insertBefore(e,o)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,r=$(_containerSelector),a=r.find("h1,h2,h3,h4,h5,h6");return $(e).html(''),a.each(function(){n=$(this).prop("tagName").toLowerCase(),i="#"+$(this).prop("id"),s=$(this).text(),t=$('<a href="'+i+'" rel="nofollow">'+s+"</a>"),o=$('<li class="'+n+'_nav"></li>').append(t),$(e).append(o)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("https://assets.cdnweb.info/hugo/cleanwhite/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>